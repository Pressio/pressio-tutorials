This page walks through writing a driver file for an L\+S\+PG R\+OM with collocation-\/based hyper-\/reduction of the shallow water equations. The full code for this coupler is available in the \href{https://github.com/Pressio/pressio-tutorials/blob/swe2d_tutorial/tutorials/swe2d/online_phase/lspg_hyperReducedRom/run_lspg_with_hyperreduction.cc}{\texttt{ pressio-\/tutorials repo}}. The first step in writing our driver is to include the relevant headers from the Pressio library. Here, we include \href{https://github.com/Pressio/pressio/blob/master/packages/pressio_apps.hpp}{\texttt{ pressio\+\_\+apps.\+hpp}}, and \href{https://github.com/Pressio/pressio/blob/master/packages/pressio_lspg.hpp}{\texttt{ pressio\+\_\+rom\+\_\+lspg.\+hpp}}, which enable us to access our Shallow Water application and L\+S\+PG capabilities, respectively.


\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{1:4}
\end{DoxyCode}


The next step for us is to start out int main file, and initialize the types for our F\+OM, as well as the scalar type 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{61:66}
\end{DoxyCode}


Note that, here we use the \href{.}{\texttt{ swe2d\+\_\+hyper}} application, opposed to the \href{.}{\texttt{ swe2d}} application. These two applications are the same, with the exception that the {\itshape swe2d\+\_\+hyper} application loads in indices for the sample and stencil mesh, and only computes the velocity/\+Jacobians at these points.

The next thing that we will do is read in information on our R\+OM, and information for hyper-\/reduction. First, we read in {\itshape info\+\_\+file.\+txt}. We wrote this file in the \href{.}{\texttt{ training phase}}, and it contains information on the size of the R\+OM, sample mesh, and sample plus stencil mesh, respectively\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{68:84}
\end{DoxyCode}


Next we create data structures that will contain our sample mesh information\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{85:90}
\end{DoxyCode}


In the above, we created
\begin{DoxyEnumerate}
\item An {\itshape std\+::vector$<$int$>$ sm\+\_\+gids} that will contain the global x,y indices of the sample mesh indices (this is required by the app). Note that this vector only contains information on the x,y cells used in the sample mesh, but not the number of conserved variables.
\item An {\itshape std\+::vector$<$int$>$ smps\+\_\+gids} that will contain the global I\+Ds of the stencil mesh (this is also required by the app). Note that this vector only contains information on the x,y cells used in the stencil mesh, but not the number of conserved variables. ~\newline

\item An {\itshape Eigen\+::\+Vector\+Xd sm\+\_\+rel\+\_\+gids} that will contain the I\+Ds of the sample mesh {\itshape relative} to the I\+Ds of the stencil mesh. Note that this vector will contain information about not only the x,y cells, but also the conserved variables, and hence it has {\itshape 3sample\+Mesh\+Size} entries. This data is required by Pressio, and is discussed more below.
\end{DoxyEnumerate}

In point 3, we create an Eigen vector that contains information about the sample mesh indices, relative to the stencil mesh. What do we mean by this? For example, let\textquotesingle{}s say our F\+OM has the (zero-\/based) indices \[ \mathcal{I}_{\text{FOM}} = \begin{Bmatrix} 0& 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 \end{Bmatrix}\] Let\textquotesingle{}s say our sample mesh uses indices 3, 5, and 7, \[ \mathcal{I}_{\text{sample}} = \begin{Bmatrix} 3 & 5 & 7 \end{Bmatrix}\] Let\textquotesingle{}s suppose we use a three-\/point stencil in our numerical method. In this case, the stencil mesh would be \[ \mathcal{I}_{\text{stencil}} = \begin{Bmatrix} 2& 3 & 4& 5 &6 & 7 & 8\end{Bmatrix}\] The indices of the {\itshape sample mesh} relative to the indices of the {\itshape stencil mesh} are thus \[ \mathcal{I}_{\text{rel}} =\begin{Bmatrix} 1 & 3 & 5 \end{Bmatrix}\] Why do we need this information? In Pressio, when we perform hyperreduction, we need to load in the basis on the {\itshape stencil mesh} so that we can reconstruct the state at these points, and eventually evaluate the velocity/residual. However, we only then evaluate the residual at the {\itshape sample mesh}, and thus we need to know what indices in the {\itshape stencil mesh} correspond to those that are on the {\itshape sample mesh}. Makes sense? Great!

We load in our sample mesh, stencil mesh, and relative sample mesh information into these vectors. Recall that we created this information in the offline stage. We load this information in by 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{90:126}
\end{DoxyCode}


In our final step for the sample mesh, we create a wrap our sample mesh relative I\+Ds with a Pressio type, 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{127:128}
\end{DoxyCode}


With these steps complete, we can now proceed with constructing our application. We define the number of grid points, domain size, and load in our testing parameter from file, 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{129:143}
\end{DoxyCode}


We note that, in the last line where we construct the application, the construct additionally requires the sample mesh information that we had loaded in.

Next, we read in the basis. Note that for hyper-\/reduction, we only read in the basis on the {\itshape stencil mesh}. The basis on the full mesh is not required. 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{144:151}
\end{DoxyCode}


We then use this basis information to construct the decoder. For hyper-\/reduced L\+S\+PG the decoder, in essence, is used to compute the product $\boldsymbol \Phi_{\text{stencil}} \hat{\boldsymbol x} $, where $\boldsymbol \Phi_{\text{stencil}}$ is the basis on the stencil mesh. 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{152:158}
\end{DoxyCode}


Next we create our reference state. For hyper-\/reduction, Pressio requires the reference state on the {\itshape stencil\+\_\+mesh}. If we want to view the entire solution field, however, we will also need the reference state on the full mesh. Here, we create both entities\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{160:164}
\end{DoxyCode}


We can now create the L\+S\+PG problem. First, we create the R\+OM state vector and initialize it to zero (again, the initial conditions are the reference state), 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{165:174}
\end{DoxyCode}


Next, we define our L\+S\+PG problem. We again use the Crank Nicolson time marching scheme, and create our L\+S\+PG problem with {\itshape pressio\+::rom\+::lspg\+::create\+Hyper\+Reduced\+Problem\+Unsteady}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{165:174}
\end{DoxyCode}


Note that in the constructor we pass the relative sample mesh indices array.

The remainder of our driver follows closely that which was written for L\+S\+PG. We define our linear and nonlinear solvers 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{179:189}
\end{DoxyCode}


Then we finally define our time steps sizes, create our observer, and solve the R\+OM 
\begin{DoxyCode}{0}
\DoxyCodeLine{@codesnippet}
\DoxyCodeLine{../../../../pressio-\/tutorials/tutorials/swe2d/online\_phase/lspg\_hyperReducedRom/run\_lspg\_with\_hyperreduction.cc}
\DoxyCodeLine{192:209}
\end{DoxyCode}


This completes our description of writing the L\+S\+PG hyper-\/reduction coupler. Click \href{./md_pages_tutorials_tutorial3.html}{\texttt{ here}} to return to the S\+WE tutorial. 