

\begin{DoxyParagraph}{}
This tutorial demonstrates how to create and use a linear decoder object for custom types, i.\+e. data types that pressio does not know how to operate on.
\end{DoxyParagraph}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}pressio/type\_traits.hpp"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}pressio/ops.hpp"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ScalarType>}
\DoxyCodeLine{\textcolor{keyword}{struct }MyCustomVector}
\DoxyCodeLine{\{}
\DoxyCodeLine{  MyCustomVector(std::size\_t ext) : d\_(ext)\{\}}
\DoxyCodeLine{}
\DoxyCodeLine{  ScalarType \& operator()(\textcolor{keywordtype}{int} i)\{ \textcolor{keywordflow}{return} d\_[i]; \}}
\DoxyCodeLine{  \textcolor{keyword}{const} ScalarType \& operator()(\textcolor{keywordtype}{int} i)\textcolor{keyword}{const }\{ \textcolor{keywordflow}{return} d\_[i]; \}}
\DoxyCodeLine{}
\DoxyCodeLine{  std::size\_t extent(\textcolor{keywordtype}{int} k)\textcolor{keyword}{const }\{ \textcolor{keywordflow}{return} (k==0) ? d\_.size() : 0; \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} fill(ScalarType value)\{}
\DoxyCodeLine{    std::for\_each(d\_.begin(), d\_.end(), [](ScalarType \& v)\{ v= 0.; \});}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{  std::vector<ScalarType> d\_ = \{\};}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ScalarType>}
\DoxyCodeLine{\textcolor{keyword}{struct }MyCustomMatrix}
\DoxyCodeLine{\{}
\DoxyCodeLine{  MyCustomMatrix(std::size\_t nr, std::size\_t nc)}
\DoxyCodeLine{    : num\_rows\_(nr), num\_cols\_(nc), d\_(nr*nc)\{\}}
\DoxyCodeLine{}
\DoxyCodeLine{  std::size\_t extent(\textcolor{keywordtype}{int} k)\textcolor{keyword}{const }\{ \textcolor{keywordflow}{return} (k==0) ? num\_rows\_ : num\_cols\_; \}}
\DoxyCodeLine{}
\DoxyCodeLine{  ScalarType \& operator()(\textcolor{keywordtype}{int} i, \textcolor{keywordtype}{int} j)\{ \textcolor{keywordflow}{return} d\_[num\_cols\_*i+j]; \}}
\DoxyCodeLine{  \textcolor{keyword}{const} ScalarType \& operator()(\textcolor{keywordtype}{int} i, \textcolor{keywordtype}{int} j)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} d\_[num\_cols\_*i+j]; \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} fill(ScalarType value)\{}
\DoxyCodeLine{    std::for\_each(d\_.begin(), d\_.end(), [=](ScalarType \& v)\{ v= value; \});}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{  std::size\_t num\_rows\_ = \{\};}
\DoxyCodeLine{  std::size\_t num\_cols\_ = \{\};}
\DoxyCodeLine{  std::vector<ScalarType> d\_ = \{\};}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{namespace }pressio\{ }
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ScalarType> }
\DoxyCodeLine{\textcolor{keyword}{struct }Traits<MyCustomVector<ScalarType>>\{}
\DoxyCodeLine{  \textcolor{keyword}{using} scalar\_type = ScalarType;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} ScalarType> }
\DoxyCodeLine{\textcolor{keyword}{struct }Traits<MyCustomMatrix<ScalarType>>\{}
\DoxyCodeLine{  \textcolor{keyword}{using} scalar\_type = ScalarType;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{namespace }ops\{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// z = beta*z + alpha * A * x}}
\DoxyCodeLine{\textcolor{comment}{// where x is subscritable as x(i)}}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} x\_t, \textcolor{keyword}{class} ScalarType>}
\DoxyCodeLine{\textcolor{keywordtype}{void} product(pressio::nontranspose,}
\DoxyCodeLine{       ScalarType alpha,}
\DoxyCodeLine{       \textcolor{keyword}{const} MyCustomMatrix<ScalarType> \& A,}
\DoxyCodeLine{       \textcolor{keyword}{const} x\_t \& x,}
\DoxyCodeLine{       ScalarType beta,}
\DoxyCodeLine{       MyCustomVector<ScalarType> \& z)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// obviously not efficient, just for demonstration}}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (std::size\_t i=0; i<A.extent(0); ++i)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    z(i) = beta*z(i);}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (std::size\_t j=0; j<A.extent(1); ++j)\{}
\DoxyCodeLine{      z(i) += alpha*A(i,j)*x(j);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\}\}\textcolor{comment}{//end namespace pressio::ops}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}pressio/rom\_decoder.hpp"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[])}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"{}Running tutorial\(\backslash\)n"{}};}
\DoxyCodeLine{  \textcolor{keyword}{using} scalar\_t        = double;}
\DoxyCodeLine{  \textcolor{keyword}{using} fom\_state\_t   = MyCustomVector<scalar\_t>;}
\DoxyCodeLine{  \textcolor{keyword}{using} decoder\_jac\_t   = MyCustomMatrix<scalar\_t>;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// create matrix and fill with ones}}
\DoxyCodeLine{  decoder\_jac\_t A(10, 3);}
\DoxyCodeLine{  A.fill(1.);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// decoder}}
\DoxyCodeLine{  \textcolor{keyword}{auto} decoder = pressio::rom::create\_time\_invariant\_linear\_decoder<fom\_state\_t>(A);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// construct reduced state}}
\DoxyCodeLine{  \textcolor{comment}{// typically, pressio reduced states for ROMs use Eigen or Kokkos (if enabled)}}
\DoxyCodeLine{  \textcolor{keyword}{using} rom\_state\_t = Eigen::VectorXd;}
\DoxyCodeLine{  rom\_state\_t yRom(A.extent(1));}
\DoxyCodeLine{  yRom.setConstant(2.);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// apply mapping}}
\DoxyCodeLine{  fom\_state\_t yFom(A.extent(0));}
\DoxyCodeLine{  decoder.applyMapping(yRom, yFom);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// check solution}}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i=0; i<yFom.extent(0); ++i)\{}
\DoxyCodeLine{    std::cout << yFom(i) << \textcolor{stringliteral}{"{} expected: "{}} << 6. << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 