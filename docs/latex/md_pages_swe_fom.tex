

\begin{DoxyParagraph}{}
This page walks through the code to solve the FOM of the SWE using Pressio\textquotesingle{}s time marching schemes. ~\newline
 The full code is available \href{https://github.com/Pressio/pressio-tutorials/blob/swe2d_tutorial/tutorials/swe2d/main_fom.cc}{\texttt{ here}}.
\end{DoxyParagraph}
First, we include the relevant headers. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}pressio\_ode\_implicit.hpp"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}pressio\_apps.hpp"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}CLI11.hpp"{}}}

\end{DoxyCode}


The main function starts by processing the command line arguments\+: this allows one to set up several parameters, but for all of the them we have default values as shown below. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[])}
\DoxyCodeLine{\{}
\DoxyCodeLine{  CLI::App app\{\textcolor{stringliteral}{"{}2D Shallow Water Equations using Eigen data types and Crank Nicolson time stepping"{}}\};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{using} scalar\_t = double;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{int} N = 64;}
\DoxyCodeLine{  scalar\_t finalTime = 10.;}
\DoxyCodeLine{  scalar\_t dt = 0.02;}
\DoxyCodeLine{  std::vector<scalar\_t> gravity = \{7.5\};}
\DoxyCodeLine{  scalar\_t pulse  = 0.125;}
\DoxyCodeLine{  std::vector<scalar\_t> forcing = \{0.2\};}
\DoxyCodeLine{}
\DoxyCodeLine{  app.add\_option(\textcolor{stringliteral}{"{}-\/N,-\/-\/numCells"{}}, N,}
\DoxyCodeLine{         \textcolor{stringliteral}{"{}Number of cells along each axis: default = 64"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{  app.add\_option(\textcolor{stringliteral}{"{}-\/T,-\/-\/finalTime"{}}, finalTime,}
\DoxyCodeLine{         \textcolor{stringliteral}{"{}Simulation time: default = 10."{}});}
\DoxyCodeLine{}
\DoxyCodeLine{  app.add\_option(\textcolor{stringliteral}{"{}-\/-\/dt"{}}, dt,}
\DoxyCodeLine{         \textcolor{stringliteral}{"{}Time step size: default = 0.02"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{  app.add\_option(\textcolor{stringliteral}{"{}-\/g,-\/-\/gravity"{}}, gravity,}
\DoxyCodeLine{         \textcolor{stringliteral}{"{}Gravity value(s) to simulate: default = 7.5"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{  app.add\_option(\textcolor{stringliteral}{"{}-\/p,-\/-\/pulse"{}}, pulse,}
\DoxyCodeLine{         \textcolor{stringliteral}{"{}Pulse magnitude, default = 0.125"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{  app.add\_option(\textcolor{stringliteral}{"{}-\/f,-\/-\/forcing"{}}, forcing,}
\DoxyCodeLine{         \textcolor{stringliteral}{"{}Forcing value(s) to simulate: default = 0.2"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{  CLI11\_PARSE(app, argc, argv);}
\DoxyCodeLine{  printInputArgs(gravity, pulse, forcing);}

\end{DoxyCode}


Then, we create some convenient types aliases. Here, we start by defining our application to be the swe2d app, and then extract the relevant types from the application class. After extracting the relevant types, we create an object of the problem of interest by specifying the number of cells to use along each axis. Be default, the app class uses a physical domain (0,5). 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using} app\_t       = ::pressio::apps::swe2d;}
\DoxyCodeLine{\textcolor{keyword}{using} app\_state\_t = \textcolor{keyword}{typename} app\_t::state\_type;}
\DoxyCodeLine{\textcolor{keyword}{using} app\_rhs\_t   = \textcolor{keyword}{typename} app\_t::velocity\_type;}
\DoxyCodeLine{\textcolor{keyword}{using} app\_jacob\_t = \textcolor{keyword}{typename} app\_t::jacobian\_type;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// create FOM object/problem: contains grid, how to compute operators, etc}}
\DoxyCodeLine{app\_t appObj(N);}

\end{DoxyCode}


Next, we construct a Crank Nicolson time stepper that we will use to march the problem in time. In Pressio, the steppers (1) act on Pressio data types that wrap the native datatype and (2) are templated on the time scheme types for the state, residual, Jacobian, and application. As such, we first define the relevant Pressio wrapped data types, and then define the stepper type. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using} ode\_state\_t     = pressio::containers::Vector<app\_state\_t>;}
\DoxyCodeLine{\textcolor{keyword}{using} ode\_residual\_t  = pressio::containers::Vector<app\_rhs\_t>;}
\DoxyCodeLine{\textcolor{keyword}{using} ode\_jacobian\_t  = pressio::containers::SparseMatrix<app\_jacob\_t>;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using} ode\_tag = pressio::ode::implicitmethods::CrankNicolson;}
\DoxyCodeLine{\textcolor{keyword}{using} stepper\_t = pressio::ode::ImplicitStepper<}
\DoxyCodeLine{  ode\_tag, ode\_state\_t, ode\_residual\_t, ode\_jacobian\_t, app\_t>;}

\end{DoxyCode}


Next, we create the linear solver that is used within the nonlinear one. Here, we use the stabilized bi-\/conjugate gradient method. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// linear solver}}
\DoxyCodeLine{\textcolor{keyword}{using} solver\_tag = pressio::solvers::linear::iterative::Bicgstab;}
\DoxyCodeLine{\textcolor{keyword}{using} lin\_solver\_t = pressio::solvers::linear::Solver<solver\_tag, ode\_jacobian\_t>;}
\DoxyCodeLine{lin\_solver\_t linSolverObj;}

\end{DoxyCode}


Finally, we define the time grid, loop over the parameter instances, and solve the FOM. 
\begin{DoxyCode}{0}
\DoxyCodeLine{  \textcolor{comment}{// solve for each parameter}}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keyword}{auto} Nsteps = \textcolor{keyword}{static\_cast<}::pressio::ode::types::step\_t\textcolor{keyword}{>}(finalTime/dt);}
\DoxyCodeLine{  \textcolor{keywordtype}{int} runCounter = 0;}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto} \& it0 : gravity)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto} \& it2 : forcing)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      \textcolor{comment}{// set physical coefficients}}
\DoxyCodeLine{      scalar\_t params[3] = \{it0, pulse, it2\};}
\DoxyCodeLine{      appObj.setParams(params);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{// initial condition}}
\DoxyCodeLine{      ode\_state\_t state(appObj.getGaussianIC(pulse));}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{// create stepper}}
\DoxyCodeLine{      stepper\_t stepperObj(state, appObj);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{// create observer (see class at top) to monitor state during time evolution}}
\DoxyCodeLine{      \textcolor{comment}{// such that the data is then stored}}
\DoxyCodeLine{      std::string filename = \textcolor{stringliteral}{"{}solution"{}};}
\DoxyCodeLine{      filename += std::to\_string(runCounter++) + \textcolor{stringliteral}{"{}.bin"{}};}
\DoxyCodeLine{      observer<ode\_state\_t> Obs(filename);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{//create nonlinear solver}}
\DoxyCodeLine{      \textcolor{keyword}{auto} NonLinSolver = pressio::solvers::nonlinear::createNewtonRaphson(stepperObj, state, linSolverObj);}
\DoxyCodeLine{      NonLinSolver.setTolerance(1e-\/11);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{comment}{// run time integration and time execution}}
\DoxyCodeLine{      \textcolor{keyword}{auto} startTime = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{      pressio::ode::advanceNSteps(stepperObj, state, 0., dt, Nsteps, Obs, NonLinSolver);}
\DoxyCodeLine{      \textcolor{keyword}{auto} finishTime = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{      \textcolor{keyword}{const} std::chrono::duration<double> elapsed2 = finishTime -\/ startTime;}
\DoxyCodeLine{      std::cout << \textcolor{stringliteral}{"{}Walltime (single FOM run) = "{}} << elapsed2.count() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}


This completes our description of writing the FOM coupler. 