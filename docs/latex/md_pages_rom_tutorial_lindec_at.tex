

\begin{DoxyParagraph}{}
This tutorial shows how to create a linear decoder object when using custom types, i.\+e. data types that pressio does not know how to operate on. Recall that a linear decoder represents a mapping of the form\+: \[ {\mathbf y}_{fom} = \mathbf{\phi} {\mathbf y}_{rom} \] where $\mathbf{\phi}$ is a matrix (for now assumed constant), $\mathbf{y}_{rom}$ is the reduced state (or generalized coordinates), and $\mathbf{y}_{fom}$ is the full-\/order model (FOM) state. A linear decoder is thus fully defined by its Jacobian matrix.
\end{DoxyParagraph}
\hypertarget{md_pages_rom_tutorial_lindec_at_autotoc_md25}{}\doxysection{Types Description}\label{md_pages_rom_tutorial_lindec_at_autotoc_md25}

\begin{DoxyItemize}
\item $\mathbf{y}_{fom}$\+: this is the FOM state and for the purposes of this tutorial, we assume to be a custom type {\ttfamily My\+Custom\+Vector}, which will be shown below.
\item $\mathbf{\phi}$\+: this is the (dense) matrix of this linear mapping (for ROMs, this can be, e.\+g., POD modes), and here we assume to be a custom type {\ttfamily My\+Custom\+Matrix}, which will be shown below.
\item $\mathbf{y}_{rom}$\+: this is the ROM state. ROM data strutures generally involve small, dense operators that fit well on a single node. In pressio, {\itshape regardless of what the FOM types are}, the data types of the ROM operators are pressio wrappers of either Eigen (always enabled) or Kokkos (optional dependency) types. The user can choose which one to use. The reason of this choice is that ROM operators are always small and dense and fit well on a single node, as explained \mbox{[}here\mbox{]}(todo).
\end{DoxyItemize}\hypertarget{md_pages_rom_tutorial_lindec_at_autotoc_md26}{}\doxysection{Custom Vector Class}\label{md_pages_rom_tutorial_lindec_at_autotoc_md26}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} scalar\_t>}
\DoxyCodeLine{\textcolor{keyword}{struct }MyCustomVector}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{using} value\_type = scalar\_t;}
\DoxyCodeLine{  \textcolor{keyword}{using} size\_type = std::size\_t;}
\DoxyCodeLine{}
\DoxyCodeLine{  MyCustomVector(std::size\_t sizeIn)}
\DoxyCodeLine{    : m\_data(sizeIn)\{\}}
\DoxyCodeLine{}
\DoxyCodeLine{  std::size\_t size()\textcolor{keyword}{ const}\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} m\_data.size();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  scalar\_t \& operator[](std::size\_t index)\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} m\_data[index];}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} scalar\_t \& operator[](std::size\_t index)\textcolor{keyword}{ const}\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} m\_data[index];}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{  std::vector<scalar\_t> m\_data;}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_pages_rom_tutorial_lindec_at_autotoc_md27}{}\doxysection{Custom Matrix Class}\label{md_pages_rom_tutorial_lindec_at_autotoc_md27}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} scalar\_t>}
\DoxyCodeLine{\textcolor{keyword}{struct }MyCustomMatrix}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{using} value\_type = scalar\_t;}
\DoxyCodeLine{  \textcolor{keyword}{using} size\_type = std::size\_t;}
\DoxyCodeLine{}
\DoxyCodeLine{  MyCustomMatrix(std::size\_t nRows, std::size\_t nCols)}
\DoxyCodeLine{    : m\_data(nRows)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \& iRow : m\_data)\{ iRow.resize(3, 0.); \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} setConstant(scalar\_t value)\{}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \& iRow : m\_data)\{}
\DoxyCodeLine{      \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \& iCol : iRow)\{}
\DoxyCodeLine{    iCol = value;}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  std::size\_t extent(\textcolor{keywordtype}{int} dim)\textcolor{keyword}{ const}\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} (dim==0) ? m\_data.size() : m\_data.front().size();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  scalar\_t \& operator()(std::size\_t row, std::size\_t col)\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} m\_data[row][col];}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} scalar\_t \& operator()(std::size\_t row, std::size\_t col)\textcolor{keyword}{ const}\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} m\_data[row][col];}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{  std::vector<std::vector<scalar\_t>> m\_data;}
\DoxyCodeLine{\};}

\end{DoxyCode}
 Our custom classes above are admittedly simple. The key point we want to convey here is that these types are literally \char`\"{}custom\char`\"{}, so totally unknown to Pressio.\hypertarget{md_pages_rom_tutorial_lindec_at_autotoc_md28}{}\doxysection{Custom Ops Class}\label{md_pages_rom_tutorial_lindec_at_autotoc_md28}
Because we are working with custom data types, we need to provide the necessary operations to do the algebra that pressio needs. This is done via an ops class as follows\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} scalar\_t>}
\DoxyCodeLine{\textcolor{keyword}{struct }MyOps}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// compue: z = beta*z + alpha * A * x}}
\DoxyCodeLine{  \textcolor{comment}{// -\/ x is an array-\/like object with the () operator to reference an element}}
\DoxyCodeLine{  \textcolor{keyword}{template}< \textcolor{keyword}{typename} x\_t>}
\DoxyCodeLine{  \textcolor{keywordtype}{void} product(pressio::nontranspose,}
\DoxyCodeLine{               scalar\_t alpha,}
\DoxyCodeLine{               \textcolor{keyword}{const} MyCustomMatrix<scalar\_t> \& A,}
\DoxyCodeLine{               \textcolor{keyword}{const} x\_t \& x,}
\DoxyCodeLine{               scalar\_t beta,}
\DoxyCodeLine{               MyCustomVector<scalar\_t> \& z)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{}
\DoxyCodeLine{    \textcolor{comment}{// obviously not efficient, just for demonstration}}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (std::size\_t i=0; i<A.extent(0); ++i)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      z[i] = beta*z[i];}
\DoxyCodeLine{      \textcolor{keywordflow}{for} (std::size\_t j=0; j<A.extent(1); ++j)\{}
\DoxyCodeLine{        z[i] += alpha*A(i,j)*x(j);}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}

\end{DoxyCode}
 The ops class needs to implement a {\ttfamily product} kernel with a specific syntax. This is what pressio will call when the mapping needs to be applied. If you are familiar with BLAS, you immediately see that {\ttfamily product} method has a BLAS-\/like API, which is done on purpose for consistency. We remark that the {\ttfamily product} method is templated on the operand, {\ttfamily x}, and that you are only guaranteeed {\ttfamily x} to support the () operator to reference an element. For this simple example, you immediately know that {\ttfamily x} will be the ROM state (or generalized coordinates), and so wonder why we have not explicitly set the type of {\ttfamily x} to be {\ttfamily pressio\+::containers\+::\+Vector$<$Eigen\+::\+Vector\+Xd$>$} since that is the ROM state type as shown in line 160. There is a reason for this\+: some ROM implementations in pressio use \href{https://en.wikipedia.org/wiki/Expression_templates}{\texttt{ expression templates}}, so the {\ttfamily apply\+Mapping} method of the decoder is not always called on a ROM state object, but must also support the case where the operand is an object that behaves like a vector but is not exactly of the same type as the ROM state. This is important to keep in mind if you code your own ops.\hypertarget{md_pages_rom_tutorial_lindec_at_autotoc_md29}{}\doxysection{Main function}\label{md_pages_rom_tutorial_lindec_at_autotoc_md29}
Now we can write the main\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[])}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"{}Running tutorial\(\backslash\)n"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// the FOM types}}
\DoxyCodeLine{  \textcolor{keyword}{using} scalar\_t           = double;}
\DoxyCodeLine{  \textcolor{keyword}{using} native\_fom\_state\_t = MyCustomVector<scalar\_t>;}
\DoxyCodeLine{  \textcolor{keyword}{using} native\_phi\_t       = MyCustomMatrix<scalar\_t>;}
\DoxyCodeLine{  \textcolor{comment}{// wrapper types aliases}}
\DoxyCodeLine{  \textcolor{keyword}{using} fom\_state\_t        = pressio::containers::Vector<native\_fom\_state\_t>;}
\DoxyCodeLine{  \textcolor{keyword}{using} decoder\_jac\_t      = pressio::containers::DenseMatrix<native\_phi\_t>;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// create a native phi and fill with ones}}
\DoxyCodeLine{  native\_phi\_t phiNative(6, 3);}
\DoxyCodeLine{  phiNative.setConstant(1.);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// ops and decoder}}
\DoxyCodeLine{  \textcolor{keyword}{using} ops\_t     = MyOps<scalar\_t>;}
\DoxyCodeLine{  \textcolor{keyword}{using} decoder\_t = pressio::rom::LinearDecoder<decoder\_jac\_t, fom\_state\_t, ops\_t>;}
\DoxyCodeLine{  ops\_t ops;}
\DoxyCodeLine{  decoder\_t decoder(phiNative, ops);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// construct reduced state, fill with 2s}}
\DoxyCodeLine{  \textcolor{keyword}{using} rom\_state\_t = pressio::containers::Vector<Eigen::VectorXd>;}
\DoxyCodeLine{  rom\_state\_t yRom(3);}
\DoxyCodeLine{  pressio::ops::fill(yRom, 2.);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// apply mapping}}
\DoxyCodeLine{  fom\_state\_t yFom(6);}
\DoxyCodeLine{  decoder.applyMapping(yRom, yFom);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// check solution}}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i=0; i<6; ++i)}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}i= "{}} << i}
\DoxyCodeLine{          << \textcolor{stringliteral}{"{}, yFom(i) = "{}}  << yFom(i)}
\DoxyCodeLine{          << \textcolor{stringliteral}{"{}, expected = "{}} << 6.}
\DoxyCodeLine{          << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_pages_rom_tutorial_lindec_at_autotoc_md30}{}\doxysection{Remark}\label{md_pages_rom_tutorial_lindec_at_autotoc_md30}
Note that the code above would work for any other \char`\"{}arbitrary\char`\"{} (not known to pressio) type, whether they are distributed or not. You can basically replace the {\ttfamily My\+Custom\+Vector} and {\ttfamily My\+Custom\+Matrix} with your target types, provide the necessary ops, and you have a working code.\hypertarget{md_pages_rom_tutorial_lindec_at_autotoc_md31}{}\doxysection{Full Code}\label{md_pages_rom_tutorial_lindec_at_autotoc_md31}
The full tutorial can be found \href{https://github.com/Pressio/pressio-tutorials/blob/master/tutorials/tut_rom_2.cc}{\texttt{ here}}. 