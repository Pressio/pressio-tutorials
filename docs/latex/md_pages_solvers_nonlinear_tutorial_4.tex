

\begin{DoxyParagraph}{}
This tutorial demonstrates how to use the normal-\/equations-\/based Gauss-\/\+Newton solver from {\ttfamily pressio/solvers\+\_\+nonlinear} using custom data types.
\end{DoxyParagraph}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <array>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <Eigen/Core>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}pressio/type\_traits.hpp"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}pressio/ops.hpp"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct }MyCustomVector}
\DoxyCodeLine{\{}
\DoxyCodeLine{  MyCustomVector(std::size\_t ext) : d\_(ext)\{\}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{double} \& operator()(\textcolor{keywordtype}{int} i)\{ \textcolor{keywordflow}{return} d\_[i]; \}}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{double} \& operator()(\textcolor{keywordtype}{int} i)\textcolor{keyword}{const }\{ \textcolor{keywordflow}{return} d\_[i]; \}}
\DoxyCodeLine{}
\DoxyCodeLine{  std::size\_t extent(\textcolor{keywordtype}{int} k)\textcolor{keyword}{const }\{ \textcolor{keywordflow}{return} (k==0) ? d\_.size() : 0; \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} fill(\textcolor{keywordtype}{double} value)\{}
\DoxyCodeLine{    std::for\_each(d\_.begin(), d\_.end(), [](\textcolor{keywordtype}{double} \& v)\{ v= 0.; \});}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{  std::vector<double> d\_ = \{\};}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct }MyCustomMatrix}
\DoxyCodeLine{\{}
\DoxyCodeLine{  MyCustomMatrix(std::size\_t nr, std::size\_t nc)}
\DoxyCodeLine{    : num\_rows\_(nr), num\_cols\_(nc), d\_(nr*nc)\{\}}
\DoxyCodeLine{}
\DoxyCodeLine{  std::size\_t extent(\textcolor{keywordtype}{int} k)\textcolor{keyword}{const }\{ \textcolor{keywordflow}{return} (k==0) ? num\_rows\_ : num\_cols\_; \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{double} \& operator()(\textcolor{keywordtype}{int} i, \textcolor{keywordtype}{int} j)\{ \textcolor{keywordflow}{return} d\_[num\_cols\_*i+j]; \}}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{double} \& operator()(\textcolor{keywordtype}{int} i, \textcolor{keywordtype}{int} j)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} d\_[num\_cols\_*i+j]; \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} fill(\textcolor{keywordtype}{double} value)\{}
\DoxyCodeLine{    std::for\_each(d\_.begin(), d\_.end(), [](\textcolor{keywordtype}{double} \& v)\{ v= 0.; \});}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{  std::size\_t num\_rows\_ = \{\};}
\DoxyCodeLine{  std::size\_t num\_cols\_ = \{\};}
\DoxyCodeLine{  std::vector<double> d\_ = \{\};}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct }MyRosenbrockSystem}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{using} scalar\_type   = double;}
\DoxyCodeLine{  \textcolor{keyword}{using} state\_type    = Eigen::VectorXd;}
\DoxyCodeLine{  \textcolor{keyword}{using} residual\_type = MyCustomVector;}
\DoxyCodeLine{  \textcolor{keyword}{using} jacobian\_type = MyCustomMatrix;}
\DoxyCodeLine{}
\DoxyCodeLine{  residual\_type createResidual()\textcolor{keyword}{ const}\{ \textcolor{keywordflow}{return} residual\_type(6);   \}}
\DoxyCodeLine{  jacobian\_type createJacobian()\textcolor{keyword}{ const}\{ \textcolor{keywordflow}{return} jacobian\_type(6, 4);\}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} residual(\textcolor{keyword}{const} state\_type\& x, residual\_type \& res)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keyword}{auto} \& x1 = x(0);}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keyword}{auto} \& x2 = x(1);}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keyword}{auto} \& x3 = x(2);}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keyword}{auto} \& x4 = x(3);}
\DoxyCodeLine{    res(0) = 10.*(x4 -\/ x3*x3);}
\DoxyCodeLine{    res(1) = 10.*(x3 -\/ x2*x2);}
\DoxyCodeLine{    res(2) = 10.*(x2 -\/ x1*x1);}
\DoxyCodeLine{    res(3) = (1.-\/x1);}
\DoxyCodeLine{    res(4) = (1.-\/x2);}
\DoxyCodeLine{    res(5) = (1.-\/x3);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{void} jacobian(\textcolor{keyword}{const} state\_type \& x, jacobian\_type \& JJ)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keyword}{auto} \& x1 = x(0);}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keyword}{auto} \& x2 = x(1);}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keyword}{auto} \& x3 = x(2);}
\DoxyCodeLine{    JJ.fill(0.);}
\DoxyCodeLine{}
\DoxyCodeLine{    JJ(0,2) = -\/20.*x3;}
\DoxyCodeLine{    JJ(0,3) = 10.;}
\DoxyCodeLine{    JJ(1,1) = -\/20.*x2;}
\DoxyCodeLine{    JJ(1,2) = 10.;}
\DoxyCodeLine{    JJ(2,0) = -\/20.*x1;}
\DoxyCodeLine{    JJ(2,1) = 10.;}
\DoxyCodeLine{    JJ(3,0) = -\/1.;}
\DoxyCodeLine{    JJ(4,1) = -\/1.;}
\DoxyCodeLine{    JJ(5,2) = -\/1.;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{namespace }pressio\{}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{struct }Traits<MyCustomVector>\{}
\DoxyCodeLine{  \textcolor{keyword}{using} scalar\_type = double;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{struct }Traits<MyCustomMatrix>\{}
\DoxyCodeLine{  \textcolor{keyword}{using} scalar\_type = double;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{namespace }ops\{}
\DoxyCodeLine{MyCustomVector clone(\textcolor{keyword}{const} MyCustomVector \& src)\{ \textcolor{keywordflow}{return} src; \}}
\DoxyCodeLine{MyCustomMatrix clone(\textcolor{keyword}{const} MyCustomMatrix \& src)\{ \textcolor{keywordflow}{return} src; \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} set\_zero(MyCustomVector \& o)\{ o.fill(0); \}}
\DoxyCodeLine{\textcolor{keywordtype}{void} set\_zero(MyCustomMatrix \& o)\{ o.fill(0); \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{double} norm2(\textcolor{keyword}{const} MyCustomVector \& v)\{}
\DoxyCodeLine{  \textcolor{keywordtype}{double} norm\{0\};}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (std::size\_t i=0; i<v.extent(0); ++i)\{}
\DoxyCodeLine{    norm += v(i)*v(i);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  \textcolor{keywordflow}{return} std::sqrt(norm);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} HessianType>}
\DoxyCodeLine{\textcolor{keywordtype}{void} product(pressio::transpose, pressio::nontranspose,}
\DoxyCodeLine{       \textcolor{keyword}{const} \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{       \textcolor{keyword}{const} MyCustomMatrix \& A,}
\DoxyCodeLine{       \textcolor{keyword}{const} \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{       HessianType \& H)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (std::size\_t i=0; i<A.extent(1); ++i)\{}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (std::size\_t j=0; j<A.extent(1); ++j)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      H(i,j) *= beta;}
\DoxyCodeLine{      \textcolor{keywordflow}{for} (std::size\_t k=0; k<A.extent(0); ++k)\{}
\DoxyCodeLine{  H(i,j) += alpha * A(k,i) * A(k,j);}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} GradientType>}
\DoxyCodeLine{\textcolor{keywordtype}{void} product(pressio::transpose,}
\DoxyCodeLine{       \textcolor{keyword}{const} \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{       \textcolor{keyword}{const} MyCustomMatrix \& A,}
\DoxyCodeLine{       \textcolor{keyword}{const} MyCustomVector \& b,}
\DoxyCodeLine{       \textcolor{keyword}{const} \textcolor{keywordtype}{double} beta,}
\DoxyCodeLine{       GradientType \& g)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (std::size\_t i=0; i<g.rows(); ++i)\{}
\DoxyCodeLine{    g(i) *= beta;}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (std::size\_t k=0; k<A.extent(0); ++k)\{}
\DoxyCodeLine{      g(i) += alpha * A(k,i) * b(k);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{class} HessianType>}
\DoxyCodeLine{HessianType product(pressio::transpose, pressio::nontranspose,}
\DoxyCodeLine{       \textcolor{keywordtype}{double} alpha,}
\DoxyCodeLine{       \textcolor{keyword}{const} MyCustomMatrix \& A)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  HessianType H(A.extent(1), A.extent(1));}
\DoxyCodeLine{  product(pressio::transpose(), pressio::nontranspose(), alpha, A, 0, H);}
\DoxyCodeLine{  \textcolor{keywordflow}{return} H;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} update(MyCustomVector \& v, \textcolor{keywordtype}{double} a, \textcolor{keyword}{const} MyCustomVector \& v1, \textcolor{keywordtype}{double} b)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (std::size\_t i=0; i<v.extent(0); ++i)\{}
\DoxyCodeLine{    v(i) = v(i)*a + b*v1(i);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} scale(MyCustomVector \& v, \textcolor{keywordtype}{double} factor)\{}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (std::size\_t i=0; i<v.extent(0); ++i)\{}
\DoxyCodeLine{    v(i) = v(i)*factor;}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{\}\}\textcolor{comment}{//end namespace pressio::ops}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}pressio/solvers\_linear.hpp"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}pressio/solvers\_nonlinear.hpp"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{namespace }plog   = pressio::log;}
\DoxyCodeLine{  \textcolor{keyword}{namespace }pls    = pressio::linearsolvers;}
\DoxyCodeLine{  \textcolor{keyword}{namespace }pnonls = pressio::nonlinearsolvers;}
\DoxyCodeLine{  plog::initialize(pressio::logto::terminal);}
\DoxyCodeLine{  plog::setVerbosity(\{plog::level::info\});}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{using} problem\_t = MyRosenbrockSystem;}
\DoxyCodeLine{  problem\_t problem;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{using} state\_t   = Eigen::VectorXd;}
\DoxyCodeLine{  state\_t x(4);}
\DoxyCodeLine{  x[0] = -\/0.05; x[1] = 1.1; x[2] = 1.2; x[3] = 1.5;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{using} hessian\_t    = Eigen::MatrixXd;}
\DoxyCodeLine{  \textcolor{keyword}{using} lin\_tag      = pls::direct::HouseholderQR;}
\DoxyCodeLine{  \textcolor{keyword}{using} lin\_solver\_t = pls::Solver<lin\_tag, hessian\_t>;}
\DoxyCodeLine{  lin\_solver\_t linSolver;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{auto} gnSolver = pnonls::create\_gauss\_newton(problem, x, linSolver);}
\DoxyCodeLine{  gnSolver.setTolerance(1e-\/5);}
\DoxyCodeLine{  gnSolver.solve(problem, x);}
\DoxyCodeLine{  std::cout << std::setprecision(14) << x << std::endl;}
\DoxyCodeLine{  \textcolor{comment}{// check solution}}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"{}Computed solution: \(\backslash\)n "{}}}
\DoxyCodeLine{            << \textcolor{stringliteral}{"{}["{}} << x(0) << \textcolor{stringliteral}{"{} "{}} << x(1) << \textcolor{stringliteral}{"{} "{}} << x(2) << \textcolor{stringliteral}{"{} "{}} << x(3) << \textcolor{stringliteral}{"{} "{}} << \textcolor{stringliteral}{"{}] \(\backslash\)n"{}}}
\DoxyCodeLine{            << \textcolor{stringliteral}{"{}Expected solution: \(\backslash\)n "{}}}
\DoxyCodeLine{            << \textcolor{stringliteral}{"{}[1.0000000156741, 0.99999999912477, 0.99999999651993, 0.99999998889888]"{}}}
\DoxyCodeLine{            << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{  plog::finalize();}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 