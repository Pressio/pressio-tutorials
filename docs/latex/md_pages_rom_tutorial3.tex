

\begin{DoxyParagraph}{}
This tutorial works through an end-\/to-\/end analysis where we use the L\+S\+PG approach to accelerate a forward model of the shallow water equations (S\+W\+Es). In this tutorial, we will\+:
\begin{DoxyEnumerate}
\item Interface an S\+WE solver, written with Eigen data structures, to Pressio.
\item Use Pressio\textquotesingle{}s time marching schemes to execute solves of the S\+W\+Es to construct training data.
\item Use supporting Python scripts to analyze the training data and construct R\+OM basis vectors.
\item Construct and run a standard L\+S\+PG R\+OM for novel parameter training instances.
\item Construct and run a hyper-\/reduced L\+S\+PG R\+OM for novel parameter training instances.
\end{DoxyEnumerate}
\end{DoxyParagraph}
\hypertarget{md_pages_rom_tutorial3_autotoc_md17}{}\doxysection{The shallow water equations}\label{md_pages_rom_tutorial3_autotoc_md17}
We consider the shallow water equations on the spatial domain $\Omega = [-\frac{L}{2},\frac{L}{2}] \times [-\frac{L}{2},\frac{L}{2}]$, which comprises the P\+DE system \[ \begin{split} &\frac{\partial h}{\partial t} + \frac{\partial}{\partial x }( h u) + \frac{\partial}{\partial y }( h v) = 0\\ &\frac{\partial h u}{\partial t} + \frac{\partial}{\partial x} (h u^2 + \frac{1}{2} \mu_1 h^2) + \frac{\partial}{\partial y }( h u v) = \mu_3 hv\\ &\frac{\partial h v}{\partial t} + \frac{\partial}{\partial x} (h u v) + \frac{\partial}{\partial y }( h v^2 + \frac{1}{2} \mu_1 h^2) = \mu_3 hu. \end{split} \] In the above, $h : \Omega \rightarrow \mathbb{R}$ is the height of the water surface, $u : \Omega \rightarrow \mathbb{R}$ is the x-\/velocity, and $v : \Omega \rightarrow \mathbb{R}$ is the y-\/velocity. The system has three parameters\+: $\mu_1$ is the gravity parameter, $\mu_2$ controls the magnitude of the initial pulse, and $\mu_3$ controls the magnitude of the Coriolis forcing.\hypertarget{md_pages_rom_tutorial3_autotoc_md18}{}\doxysection{Offline phase}\label{md_pages_rom_tutorial3_autotoc_md18}
In the offline phase, we
\begin{DoxyEnumerate}
\item Interface with and run the full-\/order model
\item Extract training data and perform proper orthogonal decomposition to find a basis for the R\+OM
\item Select indices for hyper-\/reduction by Q-\/sampling
\end{DoxyEnumerate}

We now walk through this outline phase. To run the commands provided below, set the \$\+S\+W\+E2\+D\+\_\+\+D\+IR as


\begin{DoxyCode}{0}
\DoxyCodeLine{export \$SWE2D\_DIR="{}build\_location"{}/tutorials/swe2d}
\end{DoxyCode}
\hypertarget{md_pages_rom_tutorial3_autotoc_md19}{}\doxysubsection{Running the full-\/order model}\label{md_pages_rom_tutorial3_autotoc_md19}
A full-\/order model that can be used to solve the S\+W\+Es is located in the packages/apps section of the Pressio repo (see \href{https://github.com/Pressio/pressio/tree/swe2d/packages/apps/src/swe2d}{\texttt{ here}} ). The full-\/order model employs a first-\/order finite volume discretization with the Rusanov flux scheme at the cell interfaces. ~\newline


The first step in our analysis is to run the full-\/order model for training parameter instances. To do this, we can write the driver file {\itshape run\+\_\+fom\+\_\+for\+\_\+training\+\_\+params.\+cc}. This file couples Pressio to the application, and uses Pressio\textquotesingle{}s time marching schemes to solve the model. See \href{./md_pages_tutorials_tutorial3_fom.html}{\texttt{ here}} for a step-\/by-\/step walk through of constructing this driver file. In summary, the driver file executes the full-\/order model for 9 parameter instances on the grid $\mu_1 \times \mu_3 = [3,6,9]\times [0.05,0.15,0.25]$, and saves the solutions to file.

To run the driver file, move to the offline\+\_\+phase directory and run the script\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{cd \$SWE2D\_DIR/offline\_phase}
\DoxyCodeLine{./run\_fom\_for\_training\_params}
\end{DoxyCode}


This will take some time to run, approximately 30 minutes. If successful, a series of {\itshape solution\#.bin} files should have been written. These solution files contain the F\+OM solutions at every time step for each of the nine training parameter instances. To view the results of one sample simulation, we can go to the supporting\+\_\+python\+\_\+scripts directory and run the {\itshape view\+Solution\+And\+Make\+Plots.\+py} script 
\begin{DoxyCode}{0}
\DoxyCodeLine{cd \$SWE2D\_DIR/offline\_phase/supporting\_python\_scripts}
\DoxyCodeLine{python viewSolutionAndMakePlots.py}
\end{DoxyCode}


This script will bring up a live animation of the solution for the first parameter instance.\hypertarget{md_pages_rom_tutorial3_autotoc_md20}{}\doxysubsection{Extracting the bases and building the sample mesh}\label{md_pages_rom_tutorial3_autotoc_md20}
We now need to construct the basis vectors used in the R\+OM. To do this, we again move to the supporting\+Python\+Files directory and run the {\itshape make\+Basis\+And\+Hyper\+Reduced\+Basis.\+py} script 
\begin{DoxyCode}{0}
\DoxyCodeLine{cd \$SWE2D\_DIR/offline\_phase/supporting\_python\_scripts/}
\DoxyCodeLine{python makeBasisAndHyperReducedBasis.py}
\end{DoxyCode}


This script loads in the snapshots and performs P\+OD to obtain the R\+OM basis. Additionally, this script selects cells for the sample mesh employed in hyper-\/reduction, and saves the relevant information of this sample mesh to file. Specifically, it makes the following files\+:
\begin{DoxyEnumerate}
\item {\itshape info.\+txt} This file contains information on the size of the R\+OM, the size of the sample mesh, and the size of the sample mesh and stencil mesh.
\item {\itshape basis.\+txt} This file contains the basis vectors for the R\+OM on the global mesh
\item {\itshape sample\+\_\+mesh\+\_\+gids.\+txt} This file contains the global I\+Ds of the indices used for the sample mesh
\item {\itshape sample\+\_\+mesh\+\_\+plus\+\_\+stencil\+\_\+gids.\+txt} This file contains the global I\+Ds of the indices used for the sample {\itshape and} stencil mesh
\item {\itshape Phi\+Sample\+Plus\+Stencil.\+txt} This file contains the R\+OM basis, but only at the sample mesh plus stencil mesh Additionally, this script will create a file, {\itshape samplemesh.\+png}, depicting the sample and stencil mesh. Cells in black are the sample mesh, while cells in red are on the stencil mesh.
\end{DoxyEnumerate}

\hypertarget{md_pages_rom_tutorial3_autotoc_md21}{}\doxysection{Online phase}\label{md_pages_rom_tutorial3_autotoc_md21}
With the offline stage complete, we can now run our R\+O\+Ms for novel parameter instances. We will first run a standard L\+S\+PG R\+OM without hyper-\/reduction, followed by an L\+S\+PG R\+OM with hyper-\/reduction. To set a novel parameter instance, we switch to the online directory and look at the {\itshape novel\+\_\+params.\+txt} file 
\begin{DoxyCode}{0}
\DoxyCodeLine{cd \$SWE2D\_DIR/online\_phase/}
\DoxyCodeLine{vim novel\_params.txt}
\end{DoxyCode}


By default, we have the novel parameter instance set to be $\mu_1 = 7.5, \; \mu_2=0.125, \; \mu_3 = 0.2$. The rest of this tutorial will present results for this parameter instance, but the user is encouraged to play around with different parameters and see how it impacts the results. Before we run the R\+OM, we first run a F\+OM for this new parameter instance so we can assess the accuracy of our R\+OM (of course, in a practical scenario we would not do this step!). We do not provide a detailed explanation on this driver script, since it closely follows that written previously. To run the F\+OM for our new parameter instance, we do the following\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{cd \$SWE2D\_DIR/online\_phase/fom}
\DoxyCodeLine{./run\_fom}
\end{DoxyCode}


This will run the F\+OM and save the solution to file. The F\+OM was tested on a 2.\+7 G\+Hz 12-\/Core Intel Xeon E5 core, and took 152 seconds to run.\hypertarget{md_pages_rom_tutorial3_autotoc_md22}{}\doxysubsection{L\+S\+P\+G R\+OM}\label{md_pages_rom_tutorial3_autotoc_md22}
To run an L\+S\+PG R\+OM, we write a driver file, called \href{https://github.com/Pressio/pressio-tutorials/blob/swe2d_tutorial/tutorials/swe2d/online_phase/lspg_rom/run_lspg.cc}{\texttt{ run\+\_\+lspg.\+cc}}. See \href{./md_pages_tutorials_tutorial3_lspg.html}{\texttt{ here}} for a step-\/by-\/step walk-\/through of constructing this driver file. In summary, this script couples the application to Pressio, loads in the basis information we generated in the offline phase, and couples to Pressio\textquotesingle{}s R\+OM capabilities to run an L\+S\+PG R\+OM.

To run the L\+S\+PG R\+OM, we move to the {\itshape lspg\+\_\+rom} directory, copy our R\+OM basis, and run the R\+OM,


\begin{DoxyCode}{0}
\DoxyCodeLine{cd \$SWE2D\_DIR/online\_phase/lspg\_rom}
\DoxyCodeLine{cp ../../offline\_phase/supporting\_python\_scripts/basis.txt .}
\DoxyCodeLine{./lspg\_rom}
\DoxyCodeLine{python viewSolutionAndMakePlots.py}
\end{DoxyCode}


This process saves the generalized coordinates of the R\+OM to the {\itshape solution.\+bin} file, and {\itshape view\+Solution\+And\+Make\+Plots.\+py} plots the height of the water surface for a given spatial location as a function of time, and saves the plot to {\itshape result.\+png}. This plot looks as follows\+:  The R\+OM was tested on a 2.\+7 G\+Hz 12-\/Core Intel Xeon E5 core, and took 179 seconds to run. We immediately note that our {\itshape R\+OM is slower than the F\+O\+M!} This, of course, is due to the well known bottleneck associated with nonlinear systems. To gain computational speedups, we need hyper-\/reduction. We now detail this.\hypertarget{md_pages_rom_tutorial3_autotoc_md23}{}\doxysubsection{Hyperreduced L\+S\+P\+G R\+OM}\label{md_pages_rom_tutorial3_autotoc_md23}
We now run construct and run a hyper-\/reduced L\+S\+PG R\+OM. To do this, we again need to write a driver file, which here we call \href{https://github.com/Pressio/pressio-tutorials/blob/swe2d_tutorial/tutorials/swe2d/online_phase/lspg_hyperReducedRom/run_lspg_with_hyperreduction.cc}{\texttt{ run\+\_\+lspg\+\_\+with\+\_\+hyperreduction.\+cc}}. A step-\/by-\/step tutorial for what is entailed in constructing this driver file is provided \href{./md_pages_tutorials_tutorial3_lspg_hyper.html}{\texttt{ here}}. In summary, this file loads the basis on the {\itshape stencil mesh}, loads in information about the {\itshape sample mesh} and {\itshape stencil mesh}, and then constructs and runs an L\+S\+PG R\+OM employing the collocation hyper-\/reduction technique.

To run the L\+S\+PG R\+OM with hyper-\/reduction, we move to the {\itshape lspg\+\_\+hyper\+Reduced\+Rom} directory, copy over our basis and sample mesh information, and then run our R\+OM. 
\begin{DoxyCode}{0}
\DoxyCodeLine{cd \$SWE2D\_DIR/online\_phase/lspg\_hyperReducedRom}
\DoxyCodeLine{cp ../../offline\_phase/supporting\_python\_scripts/*.txt .}
\DoxyCodeLine{./run\_lspg\_with\_hyperreduction }
\DoxyCodeLine{python viewSolutionAndMakePlots.py}
\end{DoxyCode}


If successful, the following plot will be generated.  Running the R\+OM on the same 2.\+7 G\+Hz 12-\/Core Intel Xeon E5 core machine took 20 seconds, which is about a 7.\+5x speedup over the F\+O\+M!

This completes our tutorial on R\+O\+Ms for the shallow water equations. 