<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.20" xml:lang="en-US">
  <compounddef id="md_pages_rom_tutorial3" kind="page">
    <compoundname>md_pages_rom_tutorial3</compoundname>
    <title>Tutorial: End-to-end analysis of the Shallow Water Equations with LSPG</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para> <mcss:class xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-block m-info" /></para>
<para><simplesect kind="par"><title></title><para>This tutorial works through an end-to-end analysis where we use the LSPG approach to accelerate a forward model of the shallow water equations (SWEs). In this tutorial, we will:<orderedlist>
<listitem><para>Interface an SWE solver, written with Eigen data structures, to Pressio.</para>
</listitem><listitem><para>Use Pressio&apos;s time marching schemes to execute solves of the SWEs to construct training data.</para>
</listitem><listitem><para>Use supporting Python scripts to analyze the training data and construct ROM basis vectors.</para>
</listitem><listitem><para>Construct and run a standard LSPG ROM for novel parameter training instances.</para>
</listitem><listitem><para>Construct and run a hyper-reduced LSPG ROM for novel parameter training instances.</para>
</listitem></orderedlist>
</para>
</simplesect>
<image type="html" name="swetut_f1.gif" width="90%"></image>
</para>
<sect1 id="md_pages_rom_tutorial3_1autotoc_md17">
<title>The shallow water equations</title>
<para>We consider the shallow water equations on the spatial domain <formula id="14">$\Omega = [-\frac{L}{2},\frac{L}{2}] \times [-\frac{L}{2},\frac{L}{2}]$</formula>, which comprises the PDE system <formula id="15">\[ \begin{split} &amp;\frac{\partial h}{\partial t} + \frac{\partial}{\partial x }( h u) + \frac{\partial}{\partial y }( h v) = 0\\ &amp;\frac{\partial h u}{\partial t} + \frac{\partial}{\partial x} (h u^2 + \frac{1}{2} \mu_1 h^2) + \frac{\partial}{\partial y }( h u v) = \mu_3 hv\\ &amp;\frac{\partial h v}{\partial t} + \frac{\partial}{\partial x} (h u v) + \frac{\partial}{\partial y }( h v^2 + \frac{1}{2} \mu_1 h^2) = \mu_3 hu. \end{split} \]</formula> In the above, <formula id="16">$h : \Omega \rightarrow \mathbb{R}$</formula> is the height of the water surface, <formula id="17">$u : \Omega \rightarrow \mathbb{R}$</formula> is the x-velocity, and <formula id="18">$v : \Omega \rightarrow \mathbb{R}$</formula> is the y-velocity. The system has three parameters: <formula id="19">$\mu_1$</formula> is the gravity parameter, <formula id="20">$\mu_2$</formula> controls the magnitude of the initial pulse, and <formula id="21">$\mu_3$</formula> controls the magnitude of the Coriolis forcing.</para>
</sect1>
<sect1 id="md_pages_rom_tutorial3_1autotoc_md18">
<title>Offline phase</title>
<para>In the offline phase, we<orderedlist>
<listitem><para>Interface with and run the full-order model</para>
</listitem><listitem><para>Extract training data and perform proper orthogonal decomposition to find a basis for the ROM</para>
</listitem><listitem><para>Select indices for hyper-reduction by Q-sampling</para>
</listitem></orderedlist>
</para>
<para>We now walk through this outline phase. To run the commands provided below, set the $SWE2D_DIR as</para>
<para><programlisting filename=".bash"><codeline><highlight class="normal">export<sp/>$SWE2D_DIR=&quot;build_location&quot;/tutorials/swe2d</highlight></codeline>
</programlisting></para>
<sect2 id="md_pages_rom_tutorial3_1autotoc_md19">
<title>Running the full-order model</title>
<para>A full-order model that can be used to solve the SWEs is located in the packages/apps section of the Pressio repo (see <ulink url="https://github.com/Pressio/pressio/tree/swe2d/packages/apps/src/swe2d">here</ulink> ). The full-order model employs a first-order finite volume discretization with the Rusanov flux scheme at the cell interfaces. <linebreak/>
</para>
<para>The first step in our analysis is to run the full-order model for training parameter instances. To do this, we can write the driver file <emphasis>run_fom_for_training_params.cc</emphasis>. This file couples Pressio to the application, and uses Pressio&apos;s time marching schemes to solve the model. See <ulink url="./md_pages_tutorials_tutorial3_fom.html">here</ulink> for a step-by-step walk through of constructing this driver file. In summary, the driver file executes the full-order model for 9 parameter instances on the grid <formula id="22">$\mu_1 \times \mu_3 = [3,6,9]\times [0.05,0.15,0.25]$</formula>, and saves the solutions to file.</para>
<para>To run the driver file, move to the offline_phase directory and run the script: <programlisting filename=".bash"><codeline><highlight class="normal">cd<sp/>$SWE2D_DIR/offline_phase</highlight></codeline>
<codeline><highlight class="normal">./run_fom_for_training_params</highlight></codeline>
</programlisting></para>
<para>This will take some time to run, approximately 30 minutes. If successful, a series of <emphasis>solution#.bin</emphasis> files should have been written. These solution files contain the FOM solutions at every time step for each of the nine training parameter instances. To view the results of one sample simulation, we can go to the supporting_python_scripts directory and run the <emphasis>viewSolutionAndMakePlots.py</emphasis> script <programlisting filename=".bash"><codeline><highlight class="normal">cd<sp/>$SWE2D_DIR/offline_phase/supporting_python_scripts</highlight></codeline>
<codeline><highlight class="normal">python<sp/>viewSolutionAndMakePlots.py</highlight></codeline>
</programlisting></para>
<para>This script will bring up a live animation of the solution for the first parameter instance.</para>
</sect2>
<sect2 id="md_pages_rom_tutorial3_1autotoc_md20">
<title>Extracting the bases and building the sample mesh</title>
<para>We now need to construct the basis vectors used in the ROM. To do this, we again move to the supportingPythonFiles directory and run the <emphasis>makeBasisAndHyperReducedBasis.py</emphasis> script <programlisting filename=".bash"><codeline><highlight class="normal">cd<sp/>$SWE2D_DIR/offline_phase/supporting_python_scripts/</highlight></codeline>
<codeline><highlight class="normal">python<sp/>makeBasisAndHyperReducedBasis.py</highlight></codeline>
</programlisting></para>
<para>This script loads in the snapshots and performs POD to obtain the ROM basis. Additionally, this script selects cells for the sample mesh employed in hyper-reduction, and saves the relevant information of this sample mesh to file. Specifically, it makes the following files:<orderedlist>
<listitem><para><emphasis>info.txt</emphasis> This file contains information on the size of the ROM, the size of the sample mesh, and the size of the sample mesh and stencil mesh.</para>
</listitem><listitem><para><emphasis>basis.txt</emphasis> This file contains the basis vectors for the ROM on the global mesh</para>
</listitem><listitem><para><emphasis>sample_mesh_gids.txt</emphasis> This file contains the global IDs of the indices used for the sample mesh</para>
</listitem><listitem><para><emphasis>sample_mesh_plus_stencil_gids.txt</emphasis> This file contains the global IDs of the indices used for the sample <emphasis>and</emphasis> stencil mesh</para>
</listitem><listitem><para><emphasis>PhiSamplePlusStencil.txt</emphasis> This file contains the ROM basis, but only at the sample mesh plus stencil mesh Additionally, this script will create a file, <emphasis>samplemesh.png</emphasis>, depicting the sample and stencil mesh. Cells in black are the sample mesh, while cells in red are on the stencil mesh.</para>
</listitem></orderedlist>
</para>
<para><image type="html" name="samplemesh.png" width="50%"></image>
</para>
</sect2>
</sect1>
<sect1 id="md_pages_rom_tutorial3_1autotoc_md21">
<title>Online phase</title>
<para>With the offline stage complete, we can now run our ROMs for novel parameter instances. We will first run a standard LSPG ROM without hyper-reduction, followed by an LSPG ROM with hyper-reduction. To set a novel parameter instance, we switch to the online directory and look at the <emphasis>novel_params.txt</emphasis> file <programlisting filename=".bash"><codeline><highlight class="normal">cd<sp/>$SWE2D_DIR/online_phase/</highlight></codeline>
<codeline><highlight class="normal">vim<sp/>novel_params.txt</highlight></codeline>
</programlisting></para>
<para>By default, we have the novel parameter instance set to be <formula id="23">$\mu_1 = 7.5, \; \mu_2=0.125, \; \mu_3 = 0.2$</formula>. The rest of this tutorial will present results for this parameter instance, but the user is encouraged to play around with different parameters and see how it impacts the results. Before we run the ROM, we first run a FOM for this new parameter instance so we can assess the accuracy of our ROM (of course, in a practical scenario we would not do this step!). We do not provide a detailed explanation on this driver script, since it closely follows that written previously. To run the FOM for our new parameter instance, we do the following: <programlisting filename=".bash"><codeline><highlight class="normal">cd<sp/>$SWE2D_DIR/online_phase/fom</highlight></codeline>
<codeline><highlight class="normal">./run_fom</highlight></codeline>
</programlisting></para>
<para>This will run the FOM and save the solution to file. The FOM was tested on a 2.7 GHz 12-Core Intel Xeon E5 core, and took 152 seconds to run.</para>
<sect2 id="md_pages_rom_tutorial3_1autotoc_md22">
<title>LSPG ROM</title>
<para>To run an LSPG ROM, we write a driver file, called <ulink url="https://github.com/Pressio/pressio-tutorials/blob/swe2d_tutorial/tutorials/swe2d/online_phase/lspg_rom/run_lspg.cc">run_lspg.cc</ulink>. See <ulink url="./md_pages_tutorials_tutorial3_lspg.html">here</ulink> for a step-by-step walk-through of constructing this driver file. In summary, this script couples the application to Pressio, loads in the basis information we generated in the offline phase, and couples to Pressio&apos;s ROM capabilities to run an LSPG ROM.</para>
<para>To run the LSPG ROM, we move to the <emphasis>lspg_rom</emphasis> directory, copy our ROM basis, and run the ROM,</para>
<para><programlisting filename=".bash"><codeline><highlight class="normal">cd<sp/>$SWE2D_DIR/online_phase/lspg_rom</highlight></codeline>
<codeline><highlight class="normal">cp<sp/>../../offline_phase/supporting_python_scripts/basis.txt<sp/>.</highlight></codeline>
<codeline><highlight class="normal">./lspg_rom</highlight></codeline>
<codeline><highlight class="normal">python<sp/>viewSolutionAndMakePlots.py</highlight></codeline>
</programlisting></para>
<para>This process saves the generalized coordinates of the ROM to the <emphasis>solution.bin</emphasis> file, and <emphasis>viewSolutionAndMakePlots.py</emphasis> plots the height of the water surface for a given spatial location as a function of time, and saves the plot to <emphasis>result.png</emphasis>. This plot looks as follows: <image type="html" name="result_lspg.png" width="50%"></image>
 The ROM was tested on a 2.7 GHz 12-Core Intel Xeon E5 core, and took 179 seconds to run. We immediately note that our <emphasis>ROM is slower than the FOM!</emphasis> This, of course, is due to the well known bottleneck associated with nonlinear systems. To gain computational speedups, we need hyper-reduction. We now detail this.</para>
</sect2>
<sect2 id="md_pages_rom_tutorial3_1autotoc_md23">
<title>Hyperreduced LSPG ROM</title>
<para>We now run construct and run a hyper-reduced LSPG ROM. To do this, we again need to write a driver file, which here we call <ulink url="https://github.com/Pressio/pressio-tutorials/blob/swe2d_tutorial/tutorials/swe2d/online_phase/lspg_hyperReducedRom/run_lspg_with_hyperreduction.cc">run_lspg_with_hyperreduction.cc</ulink>. A step-by-step tutorial for what is entailed in constructing this driver file is provided <ulink url="./md_pages_tutorials_tutorial3_lspg_hyper.html">here</ulink>. In summary, this file loads the basis on the <emphasis>stencil mesh</emphasis>, loads in information about the <emphasis>sample mesh</emphasis> and <emphasis>stencil mesh</emphasis>, and then constructs and runs an LSPG ROM employing the collocation hyper-reduction technique.</para>
<para>To run the LSPG ROM with hyper-reduction, we move to the <emphasis>lspg_hyperReducedRom</emphasis> directory, copy over our basis and sample mesh information, and then run our ROM. <programlisting filename=".bash"><codeline><highlight class="normal">cd<sp/>$SWE2D_DIR/online_phase/lspg_hyperReducedRom</highlight></codeline>
<codeline><highlight class="normal">cp<sp/>../../offline_phase/supporting_python_scripts/*.txt<sp/>.</highlight></codeline>
<codeline><highlight class="normal">./run_lspg_with_hyperreduction<sp/></highlight></codeline>
<codeline><highlight class="normal">python<sp/>viewSolutionAndMakePlots.py</highlight></codeline>
</programlisting></para>
<para>If successful, the following plot will be generated. <image type="html" name="result_lspgHyper.png" width="50%"></image>
 Running the ROM on the same 2.7 GHz 12-Core Intel Xeon E5 core machine took 20 seconds, which is about a 7.5x speedup over the FOM!</para>
<para>This completes our tutorial on ROMs for the shallow water equations. </para>
</sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
