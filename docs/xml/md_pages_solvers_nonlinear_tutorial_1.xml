<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="md_pages_solvers_nonlinear_tutorial_1" kind="page">
    <compoundname>md_pages_solvers_nonlinear_tutorial_1</compoundname>
    <title>Newton-Raphson with Known Types</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para> <mcss:class xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-block m-info" /></para>
<para><simplesect kind="par"><title></title><para>This tutorial demonstrates how to use the Newton-Raphson solver from <computeroutput>pressio/solvers_nonlinear</computeroutput> using data types natively supported in pressio. Here, we use Eigen data types, but a similar code can be used for other natively supported types.</para>
</simplesect>
</para>
<sect1 id="md_pages_solvers_nonlinear_tutorial_1_1autotoc_md36">
<title>Include</title>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&quot;pressio/solvers_linear.hpp&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pressio/solvers_nonlinear.hpp&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;Eigen/Core&gt;</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="md_pages_solvers_nonlinear_tutorial_1_1autotoc_md37">
<title>Problem class</title>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MySystem</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>scalar_type<sp/>=<sp/>double;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>state_type<sp/>=<sp/>Eigen::VectorXd;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>residual_type<sp/>=<sp/>state_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>jacobian_type<sp/>=<sp/>Eigen::SparseMatrix&lt;scalar_type&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>residual_type<sp/>createResidual()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>residual_type(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>jacobian_type<sp/>createJacobian()</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>jacobian_type(2,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>residual(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>state_type&amp;<sp/>x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>residual_type&amp;<sp/>res)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res(0)<sp/>=<sp/><sp/>x(0)*x(0)*x(0)<sp/>+<sp/>x(1)<sp/>-<sp/>1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>res(1)<sp/>=<sp/>-x(0)<sp/>+<sp/>x(1)*x(1)*x(1)<sp/>+<sp/>1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>jacobian(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>state_type&amp;<sp/>x,<sp/>jacobian_type&amp;<sp/>jac)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>jac.coeffRef(0,<sp/>0)<sp/>=<sp/>3.0*x(0)*x(0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>jac.coeffRef(0,<sp/>1)<sp/>=<sp/><sp/>1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>jac.coeffRef(1,<sp/>0)<sp/>=<sp/>-1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>jac.coeffRef(1,<sp/>1)<sp/>=<sp/>3.0*x(1)*x(1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="md_pages_solvers_nonlinear_tutorial_1_1autotoc_md38">
<title>Main</title>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">plog<sp/><sp/><sp/>=<sp/>pressio::log;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">pls<sp/><sp/><sp/><sp/>=<sp/>pressio::linearsolvers;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">pnonls<sp/>=<sp/>pressio::nonlinearsolvers;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>plog::initialize(pressio::logto::terminal);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>plog::setVerbosity({plog::level::info});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>problem_t<sp/><sp/>=<sp/>MySystem;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>problem_t<sp/>problemObj;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>state_t<sp/><sp/><sp/><sp/>=<sp/>problem_t::state_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>state_t<sp/>y(2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>y(0)<sp/>=<sp/>0.001;<sp/>y(1)<sp/>=<sp/>-0.1;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>linear<sp/>solver</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>jacobian_t<sp/>=<sp/>problem_t::jacobian_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>lin_solver_t<sp/>=<sp/>pls::Solver&lt;pls::iterative::LSCG,<sp/>jacobian_t&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>lin_solver_t<sp/>linearSolverObj;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>nonlinear<sp/>solvers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>nonLinSolver<sp/>=<sp/>pnonls::create_newton_raphson(problemObj,<sp/>y,<sp/>linearSolverObj);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>nonLinSolver.solve(problemObj,<sp/>y);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>check<sp/>solution</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Computed<sp/>solution:<sp/>[&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>y(0)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>y(1)<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;]<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Expected<sp/>solution:<sp/>[1.,<sp/>0.]<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>plog::finalize();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="md_pages_solvers_nonlinear_tutorial_1_1autotoc_md39">
<title>Full Code</title>
<para>The full code is available TODO. </para>
</sect1>
    </detaileddescription>
    <location file="pages/solvers_nonlinear/tutorial_1.md"/>
  </compounddef>
</doxygen>
